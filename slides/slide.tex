\documentclass[aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lipsum, lmodern}
\usepackage{fontawesome}
\usepackage{tabu}
\usepackage{braket}
\usepackage[]{qrcode}
\usepackage{setspace}
\usepackage{color}
\usepackage{listings}
\usepackage{comment}
\usepackage{array}
\usepackage[linesnumbered]{algorithm2e}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}
\RequirePackage{booktabs}
\usepackage{fontawesome}
\usepackage{tikz}  
\newcommand{\var}[1]{\mathsf{#1}}
\newcommand{\finsub}{\mathrel{\ddot{\subset}}} 
\usepackage{color,soul}


\usetikzlibrary{positioning, shapes,patterns,shadows.blur, arrows,decorations.text,arrows,automata,shadows,patterns,chains,bending,arrows.meta}
\usetikzlibrary{positioning, shapes,patterns,shadows.blur, arrows,decorations,arrows,automata,shadows,patterns,chains,graphs,calc,intersections,matrix,fit,shapes,chains,decorations.pathreplacing,chains,fit,shapes}
\usetikzlibrary{positioning, shapes,patterns,shadows.blur, arrows,decorations.text,arrows,automata,shadows,patterns,chains,bending,arrows.meta}
\usetikzlibrary{decorations.pathmorphing,shadings}
\usetikzlibrary{hobby,positioning, shapes,patterns,shadows.blur, arrows,decorations,arrows,automata,shadows,patterns,chains,graphs,calc,intersections,matrix,fit,shapes,chains,decorations.pathreplacing,calligraphy}
\usepackage{pgfplots}
\usepackage[default]{raleway}




\usepgfplotslibrary{fillbetween}
\usetheme{cau}
\tikzset{%
	initial text={},
	every state/.style={color=cau-base,left color=cau-base!60, right color=cau-base,shading angle=155,text=white,font=\tiny, blur shadow={shadow blur steps=5,shadow yshift=-0.2, shadow xshift=-0.1}},
	smallState/.style={minimum size=0.55cm},
	bigState/.style={minimum size=1cm},
	lightText/.style={color=cau-base!80},
	consideredState/.style={color=cau-base!50,left color=cau-base!20, right color=cau-base!60,shading angle=155,text=cau-base!90,minimum size=0.55cm,font=\tiny, blur shadow={shadow blur steps=5,shadow yshift=-0.2, shadow xshift=-0.1}},
	notConsideredState/.style={color=cau-base!20,left color=cau-base!10, right color=cau-base!20,shading angle=155,text=cau-base!20,minimum size=0.55cm,font=\tiny, blur shadow={shadow blur steps=5,shadow yshift=-0.1, shadow xshift=-0.1}},
	dataStyle/.style={testfg2,fill=testfg, text=testfg2,font=\large,anchor=north,rounded corners=3pt},
	datalabel/.style={color=testbg,fill=testfg2,text=testbg,rectangle,rounded corners=3pt},
	% data splits
	data1/.style={dataStyle,draw,text centered,minimum width=2.5cm},
	data2/.style={dataStyle,draw,rectangle split,rectangle split parts=2,text centered,minimum width=2.5cm},
	data2+/.style={data2,rectangle split every empty part={},% resets empty-part macro (explanation below)
		rectangle split empty part width=\widthof{#1},rectangle split empty part height=\heightof{#1},rectangle split empty part depth=\depthof{#1},},
	data3/.style={dataStyle,draw,rectangle split,rectangle split parts=3,text centered,minimum width=2.5cm},
	data3+/.style={data3,rectangle split every empty part={},% resets empty-part macro (explanation below)
		rectangle split empty part width=\widthof{#1},rectangle split empty part height=\heightof{#1},rectangle split empty part depth=\depthof{#1},},
  accepting/.style={double=testfg2!60!testfg,double distance=0.02cm}
}

% Define the base color set of the required colors
\definecolor{hks33}{RGB}{155,10,125}
\definecolor{hks37k}{RGB}{086,035,129}
\definecolor{hks12k}{RGB}{228,049,023}
\definecolor{pantone382}{RGB}{153,194,033}
\definecolor{pantone292}{RGB}{106,172,218}
\definecolor{hks63k}{RGB}{057,132,046}
\definecolor{hks6k}{RGB}{242,148,000}
\definecolor{pantone315}{RGB}{000,103,124}
\definecolor{pantone280s}{cmyk}{100,080,000,0.15}
\definecolor{pantone280s}{RGB}{000,061,143}

\newcommand{\folstruc}{\ensuremath{\mathcal{A}}}
\newcommand{\folsig}{\ensuremath{\mathcal{R}}}
\newcommand{\compdepth}{\ensuremath{\mathsf{cDepth}}}


\usetikzlibrary{positioning, arrows,automata}
\tikzset{%
	unit/.style={draw=testfg2,line width=0.15pt,rectangle, rounded corners=3pt,line width=0.15pt, color=testbg,fill=testfg2,font=\tiny,text width=1.5cm, align=center, anchor=west,rounded corners=3pt},
	%unitc1/.style={draw=testfg3,color=testfg3,fill=testfg2!97!testfg3},
	unitc1/.style={draw=testfg3!30!testbg,text=testfg2!95!testfg3,fill=testfg3!90!testbg},
	unitc2/.style={draw=testfg!30!testbg,text=testfg2!95!testfg,fill=testfg!90!testbg},
	unitc3/.style={draw=testfg4!30!testbg,text=testfg2!95!testfg4,fill=testfg4!90!testbg}
}
\title{SMTQuery}
\author{Mitja~Kulczynski}
\institute{\footnotesize Analysing SMT-LIB String Benchmarks}%\\ \tiny Kiel University}

\definecolor{colourCVC4}{HTML}{4BAC3F}
\colorlet{colourZ3Seq}{testfg2!60!testbg}
\colorlet{colourOSTRICH}{testfg2!60!testbg}
\colorlet{colourZ3-Trau}{testfg2!60!testbg}
\definecolor{colourZ3str3}{HTML}{CD3517}
\definecolor{colourZ3str3RE}{HTML}{F5B935}
\colorlet{colourSPARE}{testfg2!60!testbg}
\colorlet{colourZ3str3RE-base}{colourSPARE}
\colorlet{colourZ3str3RE-ali}{colourSPARE!20}%{0065AB}
\colorlet{colourZ3str3RE-li}{colourSPARE}%{8939AD}
\colorlet{colourZ3str3RE-asi}{colourSPARE}%{007E7A}
\colorlet{colourZ3str3RE-psh}{colourSPARE}
\colorlet{colourZ3str3RE-none}{colourSPARE}%{318700}

%%% TORN PAPER
\usepackage{lipsum}   % To generate test text
\usepackage{framed}
\usepackage{ifthen}

\newcounter{mathseed}
\setcounter{mathseed}{3}
\pgfmathsetseed{\arabic{mathseed}} % To have predictable results
% Define a background layer, in which the parchment shape is drawn
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

% This is the base for the fractal decoration. It takes a random point between the start and end, and
% raises it a random amount, thus transforming a segment into two, connected at that raised point
% This decoration can be applied again to each one of the resulting segments and so on, in a similar
% way of a Koch snowflake.
\pgfdeclaredecoration{irregular fractal line}{init}
{
  \state{init}[width=\pgfdecoratedinputsegmentremainingdistance]
  {
    \pgfpathlineto{\pgfpoint{random*\pgfdecoratedinputsegmentremainingdistance}{(random*\pgfdecorationsegmentamplitude-0.02)*\pgfdecoratedinputsegmentremainingdistance}}
    \pgfpathlineto{\pgfpoint{\pgfdecoratedinputsegmentremainingdistance}{0pt}}
  }
}


% define some styles
\tikzset{
   paper/.style={draw=black!10,fill=white},
   irregular cloudy border/.style={decoration={irregular fractal line, amplitude=0.2},
           decorate,
     },
   irregular spiky border/.style={decoration={irregular fractal line, amplitude=-0.2},
           decorate,
     },
   ragged border/.style={ decoration={random steps, segment length=7mm, amplitude=2mm},
           decorate,
   }
}

\def\tornpaper#1{%
\ifthenelse{\isodd{\value{mathseed}}}{%
\tikz{
  \node[inner sep=1em] (A) {#1};  % Draw the text of the node
  \begin{pgfonlayer}{background}  % Draw the shape behind
  \fill[paper] % recursively decorate the bottom border
     \pgfextra{\pgfmathsetseed{\arabic{mathseed}}\addtocounter{mathseed}{1}}%
      {decorate[irregular cloudy border]{decorate{decorate{decorate{decorate[ragged border]{
        (A.north west) -- (A.north east)
      }}}}}}
      -- (A.south east)
     \pgfextra{\pgfmathsetseed{\arabic{mathseed}}}%
      {decorate[irregular spiky border]{decorate{decorate{decorate{decorate[ragged border]{
      -- (A.south west)
      }}}}}}
      -- (A.north west);
  \end{pgfonlayer}}
}{%
\tikz{
  \node[inner sep=1em] (A) {#1};  % Draw the text of the node
  \begin{pgfonlayer}{background}  % Draw the shape behind
  \fill[paper] % recursively decorate the bottom border
     \pgfextra{\pgfmathsetseed{\arabic{mathseed}}\addtocounter{mathseed}{1}}%
      {decorate[irregular spiky border]{decorate{decorate{decorate{decorate[ragged border]{
        (A.north east) -- (A.north west)
      }}}}}}
      -- (A.south west)
     \pgfextra{\pgfmathsetseed{\arabic{mathseed}}}%
      {decorate[irregular cloudy border]{decorate{decorate{decorate{decorate[ragged border]{
      -- (A.south east)
      }}}}}}
      -- (A.north east);
  \end{pgfonlayer}}
}}


%%%%

% SAT

\renewcommand{\epsilon}{\varepsilon}
\newcommand{\dotequal}{\,\dot{=}\,}
\newcommand\pto{\mathrel{\ooalign{\hfil$\mapstochar$\hfil\cr$\to$\cr}}}
\renewcommand{\epsilon}{\varepsilon}
\newcommand{\variableVars}{\mathsf{V}}
\newcommand{\constsVars}{\mathsf{C}}
\newcommand{\stateVars}{\mathsf{S}}
\newcommand{\lengthbounds}[2]{\mathsf{size}(#1,#2)}
\newcommand{\wordEncoding}{\mathsf{word}}
\newcommand{\wordsMatch}{\mathsf{wm}}%{\mathsf{stateVar}}
\newcommand{\onehot}{\mathsf{oneHot}}
\newcommand{\mddVar}{\mathsf{M}}
\newcommand{\coefficients}{\mathsf{coef}_{u,v}}
\newcommand{\filledWord}[1]{#1_\xi}
\newcommand{\filledSubs}[1]{S_\xi\left(#1\right)}
\newcommand{\filledLambdaPattern}{\Xi_{\xi_\lambda}}
\newcommand{\congrel}{\overset{\filledWord{S}}{\sim}}

\newcommand{\filledSubsSet}{\left(\Sigma_\lambda \cup \Gamma \right) \times \Sigma_\lambda}
\newcommand{\subs}[2]{\left[\frac{#1}{#2}\right]}            

% tricks
\newcommand{\fakeMathCenter}[1]{\bgroup\par\centering#1\par\egroup\noindent}

\renewcommand{\epsilon}{\varepsilon}


%%% MACROS Florin
\DeclareMathOperator{\pre}{pre}
\DeclareMathOperator{\xor}{xor}
\DeclareMathOperator{\suf}{suf}
\DeclareMathOperator{\parikh}{P}
\newcommand{\shuf}{\shuffle}
\DeclareMathOperator{\subsat}{\models}
% Pattern Languages
\DeclareMathOperator{\alphabet}{alph}
\DeclareMathOperator{\symb}{symb}

\DeclareMathOperator{\erasing}{E}
\DeclareMathOperator{\nonerasing}{NE}
\DeclareMathOperator{\lang}{L}
\DeclareMathOperator{\langE}{L_{\erasing,\Sigma}}
\DeclareMathOperator{\langNE}{L_{\nonerasing,\Sigma}}

\DeclareMathOperator{\nePATSigma}{nePAT_{\Sigma}}
\DeclareMathOperator{\ePATSigma}{ePAT_{\Sigma}}
\DeclareMathOperator{\nePATtfSigma}{nePAT_{tf,\Sigma}}
\DeclareMathOperator{\ePATtfSigma}{ePAT_{tf,\Sigma}}

%Ambiguity of Morphisms, equality sets
\DeclareMathOperator{\UNAMB}{UNAMB}
\DeclareMathOperator{\eqs}{Eq}


%

\tikzset{
  double arrow/.style args={#1 colored by #2 and #3}{
    -stealth,line width=#1,#2, % first arrow
    postaction={draw,-stealth,#3,line width=(#1)/3,
      shorten <=(#1)/3,shorten >=2*(#1)/3}, % second arrow
  }
}


%%% SAT END
\newcommand*{\qlang}{\textsc{qlang}}
\newcommand{\smtop}[1]{\ensuremath{\mathtt{#1}}} % SMT operators



\begin{document}

\maketitle

\begin{frame}[c]{SMTQuery}
  \framesubtitle{A general overview.}
  \begin{quote}\centering\Large {\small $\!\!\!\!\!\!\!\!\!\!\phantom{A}^\text{\faQuoteLeft}\!\!$} {\color{ksv_blau}\bfseries SMTQuery}, a framework for storing, analysing, and querying large
    collections of SMT-LIB benchmarks.{\small $\!\!\!\phantom{A}_\text{\faQuoteRight}$}\end{quote}
\end{frame}

\begin{frame}[c]{Architecture}
\framesubtitle{A general overview.}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
    semithick]
  \tikzset{t/.style={draw=black!90,fill=none,text=black, text width=2cm, align=center,font=\small\sffamily,rounded corners=3pt,minimum height=1cm},
    nofill/.style={draw=none,fill=none}}
  \node[] (0)   {\qlang{} Query};
  \node[] (1) at ($(0)+(0,-1cm)$)  {Result};
  \node[t,fill=ksv_grau!5!white,circle,draw=black,text width=1cm] (logic) at ($(0)+(4,-0.5cm)$)  {\faCogs\\ Logic};
  \node[t,nofill] at ($(logic)+(-1.5cm,2.5cm)$) (DB)   {\faDatabase\\Database};
  \node[t,nofill] at ($(logic)+(1.5cm,2.5cm)$) (solvers)   {\faRecycle\\Solvers};
  \node[t,fill=ksv_blau,text=ksv_grau!5!white] at ($(logic)+(3.5cm,1.2cm)$) (pred)   {Predicates};
  \node[t,fill=ksv_grau!5!white] at ($(logic)+(3.5cm,0cm)$) (extr)   {Extractors};
  \node[t,fill=ksv_rot!80!ksv_grau] at ($(logic)+(3.5cm,-1.2cm)$) (fun)   {Functions};

  \node[t,nofill,text width=5cm] at ($(extr)+(4cm,1cm)$) (fs)   {\normalfont Filesystem};
  \node[t,nofill,text width=5cm] at ($(extr)+(4cm,-0.75cm)$) (smt)   {\faFile\\\scriptsize SMT-LIB Instance};
  \node[t,nofill] at ($(extr)+(4cm,0.25cm)$) (ast)   {\faTree$^\ast$\\\scriptsize AST w/ intel};
  \draw [fill=ksv_grau!5!white] ($(fs.north east)+(-1cm,-.2cm)$) -- ($(fs.north west)+(1cm,-.2cm)$) -- ($(smt.south west)+(1cm,0)$) -- ($(smt.south east)+(-1cm,0)$) -- cycle;
  \node[t,nofill,text width=5cm] at ($(extr)+(4cm,1cm)$) (fs)   {\normalfont Filesystem};
  \node[t,nofill,text width=5cm] at ($(extr)+(4cm,-0.75cm)$) (smt)   {\faFile\\\scriptsize SMT-LIB Instance};
  \node[t,nofill] at ($(extr)+(4cm,0.25cm)$) (ast)   {\faTree$^\ast$\\\scriptsize AST w/ intel};
  %\faFolderOpen
  %\faFile

  \path (pred) edge [out=0,in=180] node[] {}  ($(ast.north west)+(-0.45,-0.25)$)
  (fun) edge [out=0,in=180] node[] {}   ($(ast.south west)+(-0.45,-0.25)$)
  (extr) edge [out=0,in=180] node[] {}  ($(ast.west)+(-0.45,-0.25)$)
  (0) edge [dashed,out=0,in=170] node[] {}  (logic)
  (logic) edge [dashed,in=0,out=190] node[] {}  (1)
  (logic) edge [] node[font=\tiny] {run solvers}  (solvers)
  (solvers) edge [] node[font=\tiny] {store results}  (DB)
  (logic) edge [<->] node[font=\tiny,text width=0.5cm] {obtain data}  (DB)
  (logic) edge [in=180,out=20] node[] {}  (pred)
  (logic) edge [in=180,out=0] node[] {}  (extr)
  (logic) edge [in=180,out=-20] node[] {}  (fun)
  ;

  \draw [<->] (logic) -- ($(logic)+(0,-2cm)$) -- node[font=\tiny,yshift=-0.5cm] {access files, write ASTs and extractor output} ($(logic)+(7.5cm,-2cm)$) -- ($(logic)+(7.5cm,-1.22cm)$);
  \draw [] (solvers) -- node[font=\tiny,yshift=-0.35cm] {access files} ($(solvers)+(6cm,0cm)$) -- ($(solvers)+(6cm,-1.22cm)$);

  \end{tikzpicture}
\end{frame}

\begin{frame}[c]{Input Data}
  \framesubtitle{The underlying basis.}
  \begin{align*}
        & ({\only<2>{\color{ksv_blau}}\smtop{str.contains}} ({\only<3>{\color{ksv_rot}} s} ~"\mathit{<}") \lor {\only<2>{\color{ksv_blau}}\smtop{str.contains}}({\only<3>{\color{ksv_rot}}s} ~"\mathit{>}")) ~\rightarrow~ {\only<3>{\color{ksv_rot}}ret} = "\mathit{x}" \\
    \land~ & \neg({\only<2>{\color{ksv_blau}}\smtop{str.contains}}({\only<3>{\color{ksv_rot}}s} ~"\mathit{<}") \lor {\only<2>{\color{ksv_blau}}\smtop{str.contains}}({\only<3>{\color{ksv_rot}}s} ~"\mathit{>}")) ~\rightarrow~ {\only<3>{\color{ksv_rot}}ret} = {\only<3>{\color{ksv_rot}}s}         \\
    \land~ & {\only<2>{\color{ksv_blau}}\smtop{str.contains}}({\only<3>{\color{ksv_rot}}s}~"\mathit{sc}")                                                                                \\
    \land~ & {\only<2>{\color{ksv_blau}}\smtop{str.contains}}({\only<3>{\color{ksv_rot}}s} ~"\mathit{ript scr=}")                                                                        \\
    \land~ & {\only<3>{\color{ksv_rot}}ret} \not\,=~ "\mathit{x}"
    \end{align*}
\end{frame}


\newcommand{\getIntel}[3]{
  \node [right of=#1,box,node distance=#3,#2] (#10) {};
  \foreach \x [count=\i] in {0,1,...,5} {
          \node [box,right of=#1\x,#2] (#1\i) {};
      }
}
\begin{frame}[c]{Abstract syntax tree}
  \framesubtitle{Formulae representation.}
  \begin{tikzpicture}[->,>=stealth',shorten >=0pt,auto,node distance=3cm,
    semithick]
  \tikzset{t/.style={draw=black,color=black,fill=ksv_grau!5!white,rounded corners=3,minimum width=0.1cm,font=\tiny},
    v/.style={color=ksv_grau!5!white,fill=ksv_rot!80!ksv_grau,draw=black!60!ksv_rot},
    c/.style={color=ksv_grau!5!white,fill=ksv_blau,draw=black!60!ksv_blau},
    n/.style={draw=black!90,fill=none,text=black, align=center,font=\tiny,rounded corners=3pt,ellipse,minimum width=1cm,minimum height=0.5cm},
    box/.style={draw=black!90,minimum width=0.25cm,minimum height=0.25cm,node distance=0.25cm,rounded corners=1pt}}


  \node[t] at (0,0) (A)   {$\land$};
  %
  \node[t] at (-5.5,-1) (B)   {$\rightarrow$};
  \node[t] at (-3,-1) (C)   {$\rightarrow$};
  \node[t,c] at (0,-1) (D)   {$\smtop{str.contains}$};
  \node[t,c] at (3,-1) (E)   {$\smtop{str.contains}$};
  \node[t] at (5,-1) (F)   {$\not\,=$};
  % A
  \node[t] at (-7,-2) (A1)   {$\lor$};
  \node[t] at (-4,-2) (A2)   {$=$};
  \node[t,c] at (-8,-3) (A11)   {$\smtop{str.contains}$};
  \node[t,c] at (-6,-3) (A12)   {$\smtop{str.contains}$};
  \node[t,v] at (-8.5,-4) (A111)   {$s$};
  \node[t] at (-7.6,-4) (A112)   {$"\mathit{<}"$};
  \node[t,v] at (-6.5,-4) (A121)   {$s$};
  \node[t] at (-5.6,-4) (A122)   {$"\mathit{>}"$};

  \node[t,v] at (-4.5,-3) (A21)   {$ret$};
  \node[t] at (-3.6,-3) (A22)   {$"\mathit{x}"$};

  \node[node distance=0.5cm,below of=C]   {$\vdots$};
  \node[node distance=0.5cm,below of=D]   {$\vdots$};
  \node[node distance=0.5cm,below of=E]   {$\vdots$};
  \node[node distance=0.5cm,below of=F]   {$\vdots$};

  \path (A) edge [out=200,in=90,looseness=0.5] node[] {}  (B)
  edge [out=250,in=90,looseness=0.5] node[] {}  (C)
  edge [out=270,in=90,looseness=0.5] node[] {}  (D)
  edge [out=290,in=90,looseness=0.5] node[] {}  (E)
  edge [out=330,in=90,looseness=0.5] node[] {}  (F)
  (B) edge [out=250,in=90,looseness=0.5] node[] {}  (A1)
      edge [out=280,in=90,looseness=0.5] node[] {}  (A2)
  (A1) edge [out=250,in=90,looseness=0.5] node[] {}  (A11)
      edge [out=280,in=90,looseness=0.5] node[] {}  (A12)
  (A2) edge [out=250,in=90,looseness=0.5] node[] {}  (A21)
      edge [out=280,in=90,looseness=0.5] node[] {}  (A22)
  (A11) edge [out=250,in=90,looseness=0.5] node[] {}  (A111)
      edge [out=280,in=90,looseness=0.5] node[] {}  (A112)
  (A12) edge [out=250,in=90,looseness=0.5] node[] {}  (A121)
      edge [out=280,in=90,looseness=0.5] node[] {}  (A122)
  ;

  \end{tikzpicture}
\end{frame}

\begin{frame}[c]{Enriched AST}
  \framesubtitle{Get more out of a formula.}
    \begin{tikzpicture}[->,>=stealth',shorten >=0pt,auto,node distance=3cm,
      semithick]
    \tikzset{t/.style={color=white,draw=black,fill=ksv_blau,rounded corners=3,minimum width=0.1cm,font=\tiny},
      n/.style={draw=black!90,fill=none,text=black, align=center,font=\tiny,rounded corners=3pt,ellipse,minimum width=1cm,minimum height=0.5cm},
      box/.style={draw=black!90,fill=ksv_grau!5!white,minimum width=0.25cm,minimum height=0.25cm,node distance=0.25cm,rounded corners=1pt}}


    \node[t] (A)   {A};
    \onslide<2->{\getIntel{A}{solid}{0.65cm}}
    \node[t,below left of=A] (B)   {B};
    \onslide<2->{\getIntel{B}{solid}{0.65cm}}
    \node[t,below right of=A] (C)   {C};
    \onslide<2->{\getIntel{C}{solid}{0.65cm}}

    \node[node distance=1cm,above of=A] (top)   {$\vdots$};

    \path (A) edge [out=250,in=90] node[] {}  (B)
    edge [out=290,in=90] node[] {}  (C)
    edge [<-] node[] {} (top);


    \onslide<3->{\node[font=\Large,anchor=west] (funs) at (0,-4)   {Specify $f : N \times \mathcal{I} \rightarrow \mathcal{I}$ and $m : \mathcal{I}^n \rightarrow \mathcal{I}$ };}


    \onslide<4->{\draw [decorate,decoration = {calligraphic brace,mirror},-] ($(B0.south west)+(0,-0.1cm)$) --  ($(B6.south east)+(0,-0.1cm)$);
    \node[] (B_f) at ($(B3.south)+(0,-0.5cm)$)   {$f(B,\varepsilon)$};}

    \onslide<4->{\draw [decorate,decoration = {calligraphic brace,mirror},-] ($(C0.south west)+(0,-0.1cm)$) --  ($(C6.south east)+(0,-0.1cm)$);
    \node[] (C_f) at ($(C3.south)+(0,-0.5cm)$)   {$f(C,\varepsilon)$};}

    \node[] (M) at ($(A)+(2cm,-1cm)$)  {};
    \onslide<5->{\getIntel{M}{solid,,draw=ksv_rot!20!black,fill=ksv_rot!80!ksv_grau}{0.65cm}
    \path (M0) edge [out=180,in=90,<-,dashed,black!50,shorten <=1pt] node[] {}  (B3)
    (M5) edge [out=270,in=90,<-,dashed,black!50,shorten <=1pt] node[] {}  (C3);
    \node[anchor=west] (M_m) at ($(M6.east)+(0,0cm)$)   {merge of intels $B$ and $C$ using $m$};}


    \onslide<6->{\draw [decorate, decoration = {calligraphic brace},-] ($(A0.north west)+(0,0.1cm)$) --  ($(A6.north east)+(0,0.1cm)$);
    \node[] (A_f) at ($(A3.north)+(0.25cm,0.5cm)$,anchor=west,align=left)   {$f(A,\hspace{1.8cm})$};
    \node[] (AM) at ($(A3.north)+(-0.9cm,0.5cm)$)  {};
    \getIntel{AM}{solid,draw=ksv_rot!20!black,fill=ksv_rot!80!ksv_grau}{0.65cm}
    \path (AM5) edge [out=270,in=90,<-,dashed,black!50,shorten <=1pt] node[] {}  (M3);}

    \end{tikzpicture}
\end{frame}

\begin{frame}[c]{Predicates}
  \framesubtitle{Filter the data.}
  \begin{tikzpicture}[->,>=stealth',shorten >=0pt,auto,node distance=3cm,
    semithick]
  \tikzset{t/.style={color=white,draw=black,fill=ksv_blau,rounded corners=3,minimum width=0.1cm,font=\tiny},
    n/.style={draw=black!90,fill=none,text=black, align=center,font=\tiny,rounded corners=3pt,ellipse,minimum width=1cm,minimum height=0.5cm},
    box/.style={draw=black!90,fill=ksv_grau!5!white,minimum width=0.25cm,minimum height=0.25cm,node distance=0.25cm,rounded corners=1pt}}


  \node[t] (A)   {A};
  \getIntel{A}{solid}{0.75cm}
  \node[t,below left of=A] (B)   {B};
 \getIntel{B}{solid}{0.75cm}
  \node[t,below right of=A] (C)   {C};
 \getIntel{C}{solid}{0.75cm}

 \onslide<2->{
  \node[anchor=west] at ($(A.west)+(0.35,-0.03)$) (pA)   {$p(\hspace*{1.8cm})$};
  \node[anchor=west] at ($(B.west)+(0.35,-0.03)$) (pB)   {$p(\hspace*{1.8cm})$};
  \node[anchor=west] at ($(C.west)+(0.35,-0.03)$) (pC)   {$p(\hspace*{1.8cm})$};
 }
 \onslide<3->{
 \node[anchor=west,font=\Huge,color=ksv_blau] at ($(pA.west)+(1.8,-0.18)$)  {\faCheck};
 \node[anchor=west,font=\Huge,color=ksv_blau] at ($(pB.west)+(1.8,-0.18)$)  {\faCheck};
 \node[anchor=west,font=\Huge,color=ksv_rot] at ($(pC.west)+(1.8,-0.18)$)  {\faTimes};
 \node[anchor=west] at (4,0)  {Filter formulae based on specific properties,};
 \node[anchor=west] at (4.5,-0.5)  {e.g. \texttt{hasWEQ}, \texttt{isSAT(s)}, \texttt{isQuadratic}.};
 }
  \node[node distance=1cm,above of=A] (top)   {$\vdots$};

  \path (A) edge [out=250,in=90] node[] {}  (B)
  edge [out=290,in=90] node[] {}  (C)
  edge [<-] node[] {} (top);


  \onslide<2->{\node[font=\Large,anchor=west] (funs) at (1,-4)   {Specify $p : \mathcal{I} \rightarrow \Set{\top,\bot}$};}

  \end{tikzpicture}
\end{frame}

\begin{frame}[c]{Predicates}
  \framesubtitle{Filter the data.}
  \begin{tikzpicture}[->,>=stealth',shorten >=0pt,auto,node distance=3cm,
    semithick]
  \tikzset{t/.style={color=white,draw=black,fill=ksv_blau,rounded corners=3,minimum width=0.1cm,font=\tiny},
    n/.style={draw=black!90,fill=none,text=black, align=center,font=\tiny,rounded corners=3pt,ellipse,minimum width=1cm,minimum height=0.5cm},
    box/.style={draw=black!90,fill=ksv_grau!5!white,minimum width=0.25cm,minimum height=0.25cm,node distance=0.25cm,rounded corners=1pt}}


  \node[t] (A)   {A};
  \node[right of=A,node distance=1.25cm] (ADB)   {\faDatabase};
  \path ($(A.east)+(0.15cm,0cm)$) edge [dashed] node[] {}  (ADB);
  %\node[t,below left of=A] (B)   {B};
 %\getIntel{B}{solid}{0.75cm}
  %\node[t,below right of=A] (C)   {C};
 %\getIntel{C}{solid}{0.75cm}

 \onslide<2->{
  \node[box,below left of=ADB,node distance=3cm,font=\footnotesize] (B)   {Results solver $s_1$};
  \node[box,below right of=ADB,node distance=3cm,font=\footnotesize] (C)   {Results solver $s_2$};
  \path (ADB) edge [out=250,in=90] node[] {}  (B)
            edge [out=290,in=90] node[] {}  (C);
 
 }
 \onslide<3->{
  \node[anchor=center] at ($(B)+(-0.1cm,-0.0)$) (pB)   {$p\bigg(\hspace*{2.7cm}\bigg)$};
  \node[anchor=center] at ($(C)+(-0.1cm,-0.0)$) (pC)   {$p\bigg(\hspace*{2.7cm}\bigg)$};
 }
 \onslide<4->{
 \node[anchor=west,font=\Huge,color=ksv_blau] at ($(B.west)+(1.8,-0.18)$)  {\faCheck};
 %\node[anchor=west,font=\Huge,color=ksv_blau] at ($(pB.west)+(1.8,-0.18)$)  {\faCheck};
 %\node[anchor=west,font=\Huge,color=ksv_rot] at ($(pC.west)+(1.8,-0.18)$)  {\faTimes};
 \node[anchor=west] at (4,0)  {Filter formulae based on solver results,};
 \node[anchor=west] at (4.5,-0.5)  {e.g. \texttt{isSAT($s_1$)}.};
 }
  
  \onslide<3->{\node[font=\Large,anchor=west] (funs) at (1,-4)   {Specify $p : \mathcal{S} \rightarrow \Set{\top,\bot}$};}

  \end{tikzpicture}
\end{frame}

\begin{frame}[c]{Extractors}
  \framesubtitle{Output the data.}
  \begin{tikzpicture}[->,>=stealth',shorten >=0pt,auto,node distance=3cm,
    semithick]
  \tikzset{t/.style={color=white,draw=black,fill=ksv_blau,rounded corners=3,minimum width=0.1cm,font=\tiny},
    n/.style={draw=black!90,fill=none,text=black, align=center,font=\tiny,rounded corners=3pt,ellipse,minimum width=1cm,minimum height=0.5cm},
    box/.style={draw=black!90,fill=ksv_grau!5!white,minimum width=0.25cm,minimum height=0.25cm,node distance=0.25cm,rounded corners=1pt}}



  \node[font=\Large,anchor=center,text width=13cm,align=center] (funs) at (0,-1.5)   {Specify a function that outputs to an arbitrary format using $N \times E \times \mathcal{S} \times \mathcal{I}$.};
    \end{tikzpicture}

    \onslide<2->{
    {\tiny 
    \begin{align*}
      & (\smtop{str.contains} (s ~"\mathit{<}") \lor \smtop{str.contains}(s ~"\mathit{>}")) ~\rightarrow~ ret = "\mathit{x}" \\
  \land~ & \neg(\smtop{str.contains}(s ~"\mathit{<}") \lor \smtop{str.contains}(s ~"\mathit{>}")) ~\rightarrow~ ret = s         \\
  \land~ & \smtop{str.contains}(s~"\mathit{sc}")                                                                                \\
  \land~ & \smtop{str.contains}(s ~"\mathit{ript scr=}")                                                                        \\
  \land~ & ret \not\,=~ "\mathit{x}"
  \end{align*}}}

  \onslide<3->{
  \begin{tikzpicture}[->,>=stealth',shorten >=0pt,auto,node distance=3cm,
    semithick]
  \tikzset{t/.style={draw=black,color=black,fill=ksv_grau!5!white,rounded corners=3,minimum width=0.1cm,font=\tiny},
    v/.style={color=ksv_grau!5!white,fill=ksv_rot!80!ksv_grau,draw=black!60!ksv_rot},
    c/.style={color=ksv_grau!5!white,fill=ksv_blau,draw=black!60!ksv_blau},
    n/.style={draw=black!90,fill=none,text=black, align=center,font=\tiny,rounded corners=3pt,ellipse,minimum width=1cm,minimum height=0.5cm},
    box/.style={draw=black!90,minimum width=0.25cm,minimum height=0.25cm,node distance=0.25cm,rounded corners=1pt}}


  \node[t,v] at (-1.5,0.25) (S)   {$s$};
  \node[t,c] at (1,0.1) (RET)   {$ret$};
  %
  \node[t] at (-6,-1) (B)   {$(\smtop{str.contains} (s ~"\mathit{<}") \dots$};
  \node[t] at (-3,-1) (C)   {$\neg(\smtop{str.contains}(s ~"\mathit{<}") \dots$};
  \node[t] at (0,-1) (D)   {$ \smtop{str.contains}(s~"\mathit{sc}")$};
  \node[t] at (2.8,-1) (E)   {$\smtop{str.contains}(s ~"\mathit{ript scr=}")$};
  \node[t] at (5,-1) (F)   {$ret \not\,=~ "\mathit{x}$};

  \path (S) edge [out=190,in=100,looseness=0.5,ksv_rot!80!ksv_grau] node[] {}  (B)
  edge [out=250,in=100,looseness=0.5,ksv_rot!80!ksv_grau] node[] {}  (C)
  edge [out=270,in=100,looseness=0.5,ksv_rot!80!ksv_grau] node[] {}  (D)
  edge [out=320,in=90,looseness=0.5,ksv_rot!80!ksv_grau] node[] {}  (E)
  (RET) edge [out=200,in=70,looseness=0.5,ksv_blau] node[] {}  (B)
  edge [out=240,in=70,looseness=0.5,ksv_blau] node[] {}  (C)
  edge [out=330,in=90,looseness=0.5,ksv_blau] node[] {}  (F)



  ;

  \end{tikzpicture}}







\end{frame}

\begin{frame}[c]{MutatorA}
  \framesubtitle{Modify the data.}
  \begin{tikzpicture}[->,>=stealth',shorten >=0pt,auto,node distance=3cm,
    semithick]
  \tikzset{t/.style={color=white,draw=black,fill=ksv_blau,rounded corners=3,minimum width=0.1cm,font=\tiny},
    n/.style={draw=black!90,fill=none,text=black, align=center,font=\tiny,rounded corners=3pt,ellipse,minimum width=1cm,minimum height=0.5cm},
    box/.style={draw=black!90,fill=ksv_grau!5!white,minimum width=0.25cm,minimum height=0.25cm,node distance=0.25cm,rounded corners=1pt}}



  \node[font=\Large,anchor=center,text width=13cm,align=center] (funs) at (0,-1.5)   {Specify $f : N \times E \rightarrow N \times E$ that perfoms an arbitrary modification.};
    \end{tikzpicture}

    \onslide<2->{
      \begin{tikzpicture}[->,>=stealth',shorten >=0pt,auto,node distance=3cm,
        semithick]
      \tikzset{t/.style={draw=black,color=black,fill=ksv_grau!5!white,rounded corners=3,minimum width=0.1cm,font=\tiny},
        v/.style={color=ksv_grau!5!white,fill=ksv_rot!80!ksv_grau,draw=black!60!ksv_rot},
        c/.style={color=ksv_grau!5!white,fill=ksv_blau,draw=black!60!ksv_blau},
        n/.style={draw=black!90,fill=none,text=black, align=center,font=\tiny,rounded corners=3pt,ellipse,minimum width=1cm,minimum height=0.5cm},
        box/.style={draw=black!90,minimum width=0.25cm,minimum height=0.25cm,node distance=0.25cm,rounded corners=1pt}}
    
    
      \node[t] at (0,0) (A)   {$\land$};
      %
      \node[t] at (-5.5,-1) (B)   {$\rightarrow$};
      \node[t] at (-3,-1) (C)   {$\rightarrow$};
      \node[t] at (0,-1) (D)   {$\smtop{str.contains}$};
      \node[t] at (3,-1) (E)   {$\smtop{str.contains}$};
      \node[t] at (5,-1) (F)   {$\not\,=$};
      % A
      \node[t] at (-7,-2) (A1)   {$\lor$};
      \node[t] at (-4,-2) (A2)   {$=$};
      \node[t] at (-8,-3) (A11)   {$\smtop{str.contains}$};
      \node[t] at (-6,-3) (A12)   {$\smtop{str.contains}$};
      \node[t,v] at (-8.5,-4) (A111)   {\only<2>{$s$}\only<3>{$x_1$}};
      \node[t] at (-7.6,-4) (A112)   {$"\mathit{<}"$};
      \node[t,v] at (-6.5,-4) (A121)   {\only<2>{$s$}\only<3>{$x_1$}};
      \node[t] at (-5.6,-4) (A122)   {$"\mathit{>}"$};
    
      \node[t,c] at (-4.5,-3) (A21)   {\only<2>{$ret$}\only<3>{$x_2$}};
      \node[t] at (-3.6,-3) (A22)   {$"\mathit{x}"$};
    
      \node[node distance=0.5cm,below of=C]   {$\vdots$};
      \node[node distance=0.5cm,below of=D]   {$\vdots$};
      \node[node distance=0.5cm,below of=E]   {$\vdots$};
      \node[node distance=0.5cm,below of=F]   {$\vdots$};
    
      \path (A) edge [out=200,in=90,looseness=0.5] node[] {}  (B)
      edge [out=250,in=90,looseness=0.5] node[] {}  (C)
      edge [out=270,in=90,looseness=0.5] node[] {}  (D)
      edge [out=290,in=90,looseness=0.5] node[] {}  (E)
      edge [out=330,in=90,looseness=0.5] node[] {}  (F)
      (B) edge [out=250,in=90,looseness=0.5] node[] {}  (A1)
          edge [out=280,in=90,looseness=0.5] node[] {}  (A2)
      (A1) edge [out=250,in=90,looseness=0.5] node[] {}  (A11)
          edge [out=280,in=90,looseness=0.5] node[] {}  (A12)
      (A2) edge [out=250,in=90,looseness=0.5] node[] {}  (A21)
          edge [out=280,in=90,looseness=0.5] node[] {}  (A22)
      (A11) edge [out=250,in=90,looseness=0.5] node[] {}  (A111)
          edge [out=280,in=90,looseness=0.5] node[] {}  (A112)
      (A12) edge [out=250,in=90,looseness=0.5] node[] {}  (A121)
          edge [out=280,in=90,looseness=0.5] node[] {}  (A122)
      ;
    
      \end{tikzpicture} 
  
  }


\end{frame}

\begin{frame}[c]{Architecture}
  \framesubtitle{A general overview.}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
      semithick]
    \tikzset{t/.style={draw=black!90,fill=none,text=black, text width=2cm, align=center,font=\small\sffamily,rounded corners=3pt,minimum height=1cm},
      nofill/.style={draw=none,fill=none}}
    \node[] (0)   {\qlang{} Query};
    \node[] (1) at ($(0)+(0,-1cm)$)  {Result};
    \node[t,fill=ksv_grau!5!white,circle,draw=black,text width=1cm] (logic) at ($(0)+(4,-0.5cm)$)  {\faCogs\\ Logic};
    \node[t,nofill] at ($(logic)+(-1.5cm,2.5cm)$) (DB)   {\faDatabase\\Database};
    \node[t,nofill] at ($(logic)+(1.5cm,2.5cm)$) (solvers)   {\faRecycle\\Solvers};
    \node[t,fill=ksv_blau,text=ksv_grau!5!white] at ($(logic)+(3.5cm,1.2cm)$) (pred)   {Predicates};
    \node[t,fill=ksv_grau!5!white] at ($(logic)+(3.5cm,0cm)$) (extr)   {Extractors};
    \node[t,fill=ksv_rot!80!ksv_grau] at ($(logic)+(3.5cm,-1.2cm)$) (fun)   {Functions};
  
    \node[t,nofill,text width=5cm] at ($(extr)+(4cm,1cm)$) (fs)   {\normalfont Filesystem};
    \node[t,nofill,text width=5cm] at ($(extr)+(4cm,-0.75cm)$) (smt)   {\faFile\\\scriptsize SMT-LIB Instance};
    \node[t,nofill] at ($(extr)+(4cm,0.25cm)$) (ast)   {\faTree$^\ast$\\\scriptsize AST w/ intel};
    \draw [fill=ksv_grau!5!white] ($(fs.north east)+(-1cm,-.2cm)$) -- ($(fs.north west)+(1cm,-.2cm)$) -- ($(smt.south west)+(1cm,0)$) -- ($(smt.south east)+(-1cm,0)$) -- cycle;
    \node[t,nofill,text width=5cm] at ($(extr)+(4cm,1cm)$) (fs)   {\normalfont Filesystem};
    \node[t,nofill,text width=5cm] at ($(extr)+(4cm,-0.75cm)$) (smt)   {\faFile\\\scriptsize SMT-LIB Instance};
    \node[t,nofill] at ($(extr)+(4cm,0.25cm)$) (ast)   {\faTree$^\ast$\\\scriptsize AST w/ intel};
    %\faFolderOpen
    %\faFile
  
    \path (pred) edge [out=0,in=180] node[] {}  ($(ast.north west)+(-0.45,-0.25)$)
    (fun) edge [out=0,in=180] node[] {}   ($(ast.south west)+(-0.45,-0.25)$)
    (extr) edge [out=0,in=180] node[] {}  ($(ast.west)+(-0.45,-0.25)$)
    (0) edge [dashed,out=0,in=170] node[] {}  (logic)
    (logic) edge [dashed,in=0,out=190] node[] {}  (1)
    (logic) edge [] node[font=\tiny] {run solvers}  (solvers)
    (solvers) edge [] node[font=\tiny] {store results}  (DB)
    (logic) edge [<->] node[font=\tiny,text width=0.5cm] {obtain data}  (DB)
    (logic) edge [in=180,out=20] node[] {}  (pred)
    (logic) edge [in=180,out=0] node[] {}  (extr)
    (logic) edge [in=180,out=-20] node[] {}  (fun)
    ;
  
    \draw [<->] (logic) -- ($(logic)+(0,-2cm)$) -- node[font=\tiny,yshift=-0.5cm] {access files, write ASTs and extractor output} ($(logic)+(7.5cm,-2cm)$) -- ($(logic)+(7.5cm,-1.22cm)$);
    \draw [] (solvers) -- node[font=\tiny,yshift=-0.35cm] {access files} ($(solvers)+(6cm,0cm)$) -- ($(solvers)+(6cm,-1.22cm)$);
  
    \end{tikzpicture}
  \end{frame}


  \newcommand{\Coloneqq}{::=}
  \newcommand{\vsep}{~|~}

  \begin{frame}[c]{\qlang}
    \framesubtitle{The query language.}
    {\small
  $$\begin{array}{lcll}
    S   & \Coloneqq & \texttt{Select } f_s \texttt{ From } d \texttt{ Where } c \!\vsep\! \texttt{Extract } \text{\colorbox{ksv_grau!5!white}{$f_e$}} \texttt{ From } d \texttt{ Where } c \texttt{ Apply } \text{\colorbox{ksv_rot!80!ksv_grau}{\color{white}$\textsc{Function}$}} \\
    f_s & \Coloneqq & \texttt{Name} \vsep \texttt{Hash} \vsep \texttt{Content}                                                                                                          \\
    f_e & \Coloneqq & \texttt{SMTLib} \vsep{} \texttt{SMTPlot}                                                                                                                          % \vsep \texttt{LINEARLENGTH} \vsep \texttt{REGEX} \vsep \texttt{HOFUNCTION} \\ & & 
    \vsep \dots                                                                                                                                                                         \\ %\vsep f_e\texttt{, } f_e\\
    d   & \Coloneqq & \texttt{*} \vsep \textsc{Set} \vsep \textsc{Set}\texttt{:}\textsc{Track} \vsep d\texttt{, } d                                                                     \\
    c   & \Coloneqq & \text{\colorbox{ksv_blau}{\color{white}$\textsc{Predicate}$}} \vsep (c \texttt{ And } c) \vsep (c \texttt{ Or } c)  \vsep (\texttt{Not } c) \vsep \texttt{True} \vsep \texttt{False}                         \\
  \end{array}$$}

  \vspace*{0.5cm}

  \onslide<2->{
    \begin{center}
      {\Large\color{ksv_blau} 1.~}\texttt{Select Name From Woorpje:Track01 Where ((Not \text{\colorbox{ksv_blau}{\color{white}hasRegex}}) And \text{\colorbox{ksv_blau}{\color{white}hasWEQ}})}\\
      \vspace{0.1cm}
     {\Large\color{ksv_blau} 2.~}\texttt{Extract \text{\colorbox{ksv_grau!5!white}{VarDepPlot}} From Woorpje Where \text{\colorbox{ksv_blau}{\color{white}isSAT(CVC5)}} Apply \text{\colorbox{ksv_rot!80!ksv_grau}{\color{white}RestrictToWEQ}}}
    \end{center}
  }
\end{frame}

\maketitle


\end{document}